## Reto 1

En la f√°brica de juguetes del Polo Norte, cada juguete tiene un n√∫mero de identificaci√≥n √∫nico.

Sin embargo, debido a un error en la m√°quina de juguetes, algunos n√∫meros se han asignado a m√°s de un juguete.

¬°Encuentra el primer n√∫mero de identificaci√≥n que se ha repetido, donde la segunda ocurrencia tenga el √≠ndice m√°s peque√±o!

En otras palabras, si hay m√°s de un n√∫mero repetido, debes devolver el n√∫mero cuya segunda ocurrencia aparezca primero en la lista. Si no hay n√∫meros repetidos, devuelve -1.

``` javascript
const giftIds = [2, 1, 3, 5, 3, 2]
const firstRepeatedId = findFirstRepeated(giftIds)
console.log(firstRepeatedId) // 3
// Aunque el 2 y el 3 se repiten
// el 3 aparece primero por segunda vez

const giftIds2 = [1, 2, 3, 4]
const firstRepeatedId2 = findFirstRepeated(giftIds2)
console.log(firstRepeatedId2) // -1
// Es -1 ya que no se repite ning√∫n n√∫mero

const giftIds3 = [5, 1, 5, 1]
const firstRepeatedId3 = findFirstRepeated(giftIds3)
console.log(firstRepeatedId3) // 5
```

¬°Ojo! Los elfos dicen que esto es una prueba t√©cnica de Google.

## Reto 2

En el taller de Santa, los elfos tienen una lista de regalos que desean fabricar y un conjunto limitado de materiales.

Los regalos son cadenas de texto y los materiales son caracteres. Tu tarea es escribir una funci√≥n que, dada una lista de regalos y los materiales disponibles, devuelva una lista de los regalos que se pueden fabricar.

Un regalo se puede fabricar si contamos con todos los materiales necesarios para fabricarlo.

``` javascript
const gifts = ['tren', 'oso', 'pelota']
const materials = 'tronesa'

manufacture(gifts, materials) // ["tren", "oso"]
// 'tren' S√ç porque sus letras est√°n en 'tronesa'
// 'oso' S√ç porque sus letras est√°n en 'tronesa'
// 'pelota' NO porque sus letras NO est√°n en 'tronesa'

const gifts = ['juego', 'puzzle']
const materials = 'jlepuz'

manufacture(gifts, materials) // ["puzzle"]

const gifts = ['libro', 'ps5']
const materials = 'psli'

manufacture(gifts, materials) // []
```

## Reto 3

En el taller de Santa, un elfo travieso ha estado jugando en la cadena de fabricaci√≥n de regalos, a√±adiendo o eliminando un paso no planificado.

Tienes la secuencia original de pasos en la fabricaci√≥n original y la secuencia modificada modified que puede incluir un paso extra o faltar un paso.

Tu tarea es escribir una funci√≥n que identifique y devuelva el primer paso extra que se ha a√±adido o eliminado en la cadena de fabricaci√≥n. Si no hay ninguna diferencia entre las secuencias, devuelve una cadena vac√≠a.

``` javascript
const original = 'abcd'
const modified = 'abcde'
findNaughtyStep(original, modified) // 'e'

const original = 'stepfor'
const modified = 'stepor'
findNaughtyStep(original, modified) // 'f'

const original = 'abcde'
const modified = 'abcde'
findNaughtyStep(original, modified) // ''
```

A tener en cuenta:

- Siempre habr√° un paso de diferencia o ninguno.
- La modificaci√≥n puede ocurrir en cualquier lugar de la cadena.
- La secuencia original puede estar vac√≠a

## reto 4

En el taller de Santa üéÖ, algunos mensajes navide√±os han sido escritos de manera peculiar: las letras dentro de los par√©ntesis deben ser le√≠das al rev√©s

Santa necesita que estos mensajes est√©n correctamente formateados. Tu tarea es escribir una funci√≥n que tome una cadena de texto y revierta los caracteres dentro de cada par de par√©ntesis, eliminando los par√©ntesis en el mensaje final.

Eso s√≠, ten en cuenta que pueden existir par√©ntesis anidados, por lo que debes invertir los caracteres en el orden correcto.

``` javascript
const a = decode('hola (odnum)')
console.log(a) // hola mundo

const b = decode('(olleh) (dlrow)!')
console.log(b) // hello world!

const c = decode('sa(u(cla)atn)s')
console.log(c) // santaclaus

// Paso a paso:
// 1. Invertimos el anidado -> sa(ualcatn)s
// 2. Invertimos el que queda -> santaclaus
```

Notas:

- Las cadenas de entrada siempre estar√°n bien formadas con par√©ntesis que coinciden correctamente, no necesitas validarlos.
- En el mensaje final no deben quedar par√©ntesis.
- El nivel m√°ximo de anidamiento es 2.

## Reto 5

Santa üéÖ est√° probando su nuevo trineo el√©ctrico, el CyberReindeer, en una carretera del Polo Norte. La carretera se representa con una cadena de caracteres, donde:

    . = Carretera
    S = Trineo de Santa
    * = Barrera abierta
    | = Barrera cerrada

Ejemplo de carretera: `S...|....|.....`

Cada unidad de tiempo, el trineo avanza una posici√≥n a la derecha. Si encuentra una barrera cerrada, se detiene hasta que la barrera se abra. Si est√° abierta, la atraviesa directamente.

Todas las barreras empiezan cerradas, pero despu√©s de 5 unidades de tiempo, se abren todas para siempre.

Crea una funci√≥n que simule el movimiento del trineo durante un tiempo dado y devuelva un array de cadenas representando el estado de la carretera en cada unidad de tiempo:

``` javascript
const road = 'S..|...|..'
const time = 10 // unidades de tiempo
const result = cyberReindeer(road, time)

/* -> result:
[
'S..|...|..', // estado inicial
'.S.|...|..', // avanza el trineo la carretera
'..S|...|..', // avanza el trineo la carretera
'..S|...|..', // el trineo para en la barrera
'..S|...|..', // el trineo para en la barrera
'...S...*..', // se abre la barrera, el trineo avanza
'...*S..*..', // avanza el trineo la carretera
'...*.S.*..', // avanza el trineo la carretera
'...*..S*..', // avanza el trineo la carretera
'...*...S..', // avanza por la barrera abierta
]
*/
```

El resultado es un array donde cada elemento muestra la carretera en cada unidad de tiempo.

Ten en cuenta que si el trineo est√° en la misma posici√≥n que una barrera, entonces toma su lugar en el array.

Los elfos se inspiraron en este reto de Code Wars.

## Reto 6

Los elfos est√°n catalogando los renos de Santa ü¶å seg√∫n la distancia que pueden recorrer.

Para ello tienen una cadena de texto movements donde cada caracter representa la direcci√≥n del movimiento del reno:

- `> = Avanza a la derecha`
- `< = Avanza a la izquierda`
- `* = Puede avanzar o retroceder`

Por ejemplo, si el movimiento es `>>*<`, va hacia la derecha dos veces, luego puede ir a derecha o izquierda (lo que maximice la distancia recorrida final) y luego ir a la izquierda.

Los elfos quieren saber cu√°l es la m√°xima distancia que recorre el reno al finalizar todos los movimientos.

En el ejemplo anterior, la m√°xima distancia que recorre el reno es 2. Va a la derecha dos veces +2, luego con el * puede ir a la derecha otra vez para maximizar la distancia +1 y luego va a la izquierda -1.

Crea una funci√≥n maxDistance que reciba la cadena de texto movements y devuelva la m√°xima distancia que puede recorrer el reno en cualquier direcci√≥n:

``` javascript 
const movements = '>>*<'
const result = maxDistance(movements)
console.log(result) // -> 2

const movements2 = '<<<>'
const result2 = maxDistance(movements2)
console.log(result2) // -> 2

const movements3 = '>***>'
const result3 = maxDistance(movements3)
console.log(result3) // -> 5
```

Ten en cuenta que no importa si es a la izquierda o la derecha, la distancia es el valor absoluto de la distancia recorrida m√°xima al finalizar los movimientos.

## Reto 7

Santa est√° experimentando con nuevos dise√±os de regalos y necesita tu ayuda para visualizarlos en 3D.

Tu tarea es escribir una funci√≥n que, dado un tama√±o n (entero), genere un dibujo de un regalo en 3D utilizando caracteres ASCII.

Las l√≠neas de los regalos se dibujan con # y las caras con el s√≠mbolo que nos pasan como par√°metro:

``` javascript
drawGift(4, '+')

/*
####
#++##
#++#+#
####++#
#++#+#
#++##
####
*/

drawGift(5, '*')
/*
#####
#***##
#***#*#
#***#**#
#####***#
#***#**#
#***#*#
#***##
#####
*/

drawGift(1, '^')
/*
#
*/
```

Importante: Nos han dicho que siempre hay que dejar un salto de l√≠nea al final del dibujo.

Nota: Ten en cuenta que, en los tests, la primera l√≠nea se ve empujada por el caracter `"`.

## Reto 8

Los elfos est√°n muy ocupados en el taller de Santa Claus organizando regalos üéÅ para la v√≠spera de Navidad üéÑ.

El formato de entrada es especial, ya que indica el n√∫mero de regalos y el tipo de regalo con letras de la a a la z. Por ejemplo, '66a11b' significa 66 regalos a y 11 regalos b.

Los elfos tienen un sistema especial para organizar los regalos:

    Cada 10 regalos del mismo tipo se empaquetan en una caja, representada por {x}. Por ejemplo, 20 regalos tipo a se empaquetan en 2 cajas as√≠: {a}{a}.
    Cada 5 cajas se apilan en un pal√©, representado por [x]. Por ejemplo, 10 cajas de a se apilan en 2 pal√©s de esta manera: [a][a]
    Cualquier regalo adicional se coloca en una bolsa, representada por () y se colocan todas dentro. Por ejemplo 4 regalos de b se colocan en una bolsa as√≠ (bbbb)

Los regalos luego se colocan en el siguiente orden: pal√©s, cajas y bolsas. Y los regalos aparecen en el mismo orden que la cadena de entrada.

Tu tarea es escribir una funci√≥n organizeGifts que tome una cadena de regalos como argumento y devuelva una cadena representando el almac√©n.

``` javascript
const result1 = organizeGifts(`76a11b`)
console.log(result1)
// '[a]{a}{a}(aaaaaa){b}(b)'

/* Explicaci√≥n:

  76a: 76 regalos tipo 'a' se empaquetar√≠an en 7 cajas y sobrar√≠an 6 regalos, resultando en 1 pal√© [a] (por las primeras 5 cajas), 2 cajas sueltas {a}{a} y una bolsa con 6 regalos (aaaaaa)

  11b: 11 regalos tipo 'b' se empaquetar√≠an en 1 caja y sobrar√≠a 1 regalo, resultando en 1 caja suelta {b} y una bolsa con 1 regalo (b)
*/
``` 